//#include <iostream>
//using namespace std;
//
//
//class C
//{
//public:
//    int a;
//    C()                     // 构造函数
//    {
//        cout << "CONSTRUCTOR" << endl;
//    }
//
//    C(const C& a)           // 拷贝构造函数
//    {
//        cout << "COPY CONSTRUCTOR" << endl;
//    }
//};
//
//void func1(C c)
//{
//
//}
//
//C func2()
//{
//    C cc;
//    return cc;
//}
//
//int main()
//{
//    C c;
//    c.a = 12;
//
//    // 新建一个对象，并将其初始化为同类现有对象
//    C c1(c);
//    C c2 = c;
//    C c3 = C(c);
//    C* c4 = new C(c);
//
//    C c5;
//    cout << c5.a << endl;
//    c5 = c;
//    cout << c5.a << endl;   // 这里测试结果显示，对象之间的赋值不会调用拷贝构造函数，但是也能复制全部的非静态成员
//
//    // 当程序生成对象副本
//    func1(c);
//    func2();                // 测试后发现并不会调用拷贝构造函数
//
//    return 0;
//}


/*
 * 0.默认的拷贝构造函数会自动复制被拷贝对象的所有非静态成员，所以这个函数会在拷贝一个对象时自动调用，以实现拷贝的目的。
 * 1.拷贝构造函数是构造函数的重载函数，其参数本类对象的常引用：const C& a。因此，可以推测，当实例化对象时参数如果是本类的对象，那么会调
 *   用拷贝构造函数。
 * 2.拷贝构造函数调用的情况有2种：1）新建一个对象，并将其初始化为同类现有对象；2）当程序生成对象副本时。
 * 3.程序生成对象副本有2种情况：1）对象作为函数参数：此时形参本质上是一个初始化为实参的局部变量；2）对象作为返回值：此时函数表达式返回的
 *   是一个临时对象，这个临时对象被初始化为需要返回的对象。
 * 4.这里涉及到的函数形参和返回值的本质值得记录一下：1）形参的本质是初始化为实参值的局部变量；2）函数的返回值是通过定义一个临时对象传递
 *   出去的。
 */