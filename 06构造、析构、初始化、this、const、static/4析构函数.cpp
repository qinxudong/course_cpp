////
//// Created by qin on 18-12-3.
////
//
//#include <iostream>
//using namespace std;
//
//class C
//{
//public:
//    int n;
//
//    void print()
//    {
//        cout << "执行函数" << endl;
//    }
//
//    C()
//    {
//        cout << "构造函数" << endl;
//    }
//
//    ~C()                    // 析构函数的形式：~classname(){}
//    {
//        cout << "析构函数" << endl;
//    }
//};
//
//int main()
//{
//    {
//        C c;                // 创建对象c时调用构造函数，到花括号结束时局部变量c会被释放，此时调用析构函数
//    }
//
//    C* cc = new C;          // 创建指针对象，new出来的内存都在堆区，必须delete操作才会释放内存，因此在delete操作时调用析构函数
////    delete cc;
//
//    C().print();            // 创建临时对象，作用域只有一行，因此本行结束时调用析构函数
//
//    C* ccc = (C*)malloc(sizeof(C));     // malloc(sizeof(class))分配内存，返回void*类型指针，然后(C*)转换指针类型再赋值给ccc
//
//    return 0;
//}
//
//
///*
// * 1.析构函数与构造函数对应。构造函数是对象被创建(实例化)时被自动调用的函数，析构函数是对象被释放(内存释放)时自动调用的函数。
// * 2.析构函数只能有一个(不能重载)，没有参数。
// * 3.一般对象是在其所在花括号结束时释放内存，但在函数中return关键字会结束函数代码，释放内存，因此析构函数会在return之前执行。
// * 4.局部变量(对象)都在栈区，系统在作用域结束后自动释放；new出来的变量(对象)都在堆区，必须delete释放内存。因此两种方式调用析构函数的时
// *   间不同。
// * 5.临时对象的创建方法：classname()，虽然没有指定对象名但是可以直接.func()调用函数或者其他成员。作用域只有一行，一行结束内存即被释放。
// * 6.析构函数与构造函数对应，比如构造函数一般用来初始化类的数据成员，那么析构函数一般用来清理类中的数据。比如在构造函数中new了内存，那么
// *   就可以在析构函数中delete掉。
// * 7.正如在第二节中提到的，malloc和free不会调用构造和析构函数。
// */